

# This file was *autogenerated* from the file assignment_4.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_511 = Integer(511); _sage_const_1 = Integer(1); _sage_const_16 = Integer(16); _sage_const_0 = Integer(0)
from sage.all import *
from random import randint

# Function to generate a random prime number
def generate_prime():
    return random_prime(_sage_const_2 **_sage_const_512 , False, _sage_const_2 **_sage_const_511 )

# Function to generate key pairs
def generate_keys():
    p = generate_prime()
    q = generate_prime()
    N = p * q
    phi_N = (p - _sage_const_1 ) * (q - _sage_const_1 )
    d = randint(_sage_const_2 , phi_N)
    while gcd(d, phi_N) != _sage_const_1 :
        d = randint(_sage_const_2 , phi_N)
    e = inverse_mod(d, phi_N)
    return N, e, d, p, q

# Function to sign a message using CRT
def sign_message(msg, N, d, p, q):
    m = Integer(msg.encode("utf-8").hex(), _sage_const_16 )
    sp = power_mod(m, d % (p - _sage_const_1 ), p)
    sq = power_mod(m, d % (q - _sage_const_1 ), q)
    s = crt([sp, sq], [p, q])
    return s % N

# Function to recover factorization from s and sp_error using Bellcore attack
def recover_factorization(N, sp_error, sq, p, q):
    # Compute u = (s % q) * (q^-1 % p) mod p
    u = (sq * inverse_modulus(q, p)) % p

    # Compute v = (sp_error % p) * (p^-1 % q) mod q
    v = (sp_error * inverse_modulus(p, q)) % q

    # Compute x = (u * q * p + v * p) mod N
    x = (u * q * p + v * p) % N

    # Compute y = (x % 2p) - p
    y = (x % (_sage_const_2  * p)) - p

    # Initialize gcd to None
    gcd = None

    # Keep looping until gcd is not equal to 1 and not equal to N
    while gcd is None or gcd == _sage_const_1  or gcd == N:
        y += _sage_const_2  * p
        gcd = gcd(x + y, N)

    factors = [gcd, N // gcd]
    return factors


# Function to detect error in sp using Bellcore attack
def detect_error(N, sp_error, sq, p, q):
    # Compute u = (s % q) * (q^-1 % p) mod p
    u = (sq * inverse_modulus(q, p)) % p

    # Compute v = (sp_error % p) * (p^-1 % q) mod q
    v = (sp_error * inverse_modulus(p, q)) % q

    # Compute x = (u * q * p + v * p) mod N
    x = (u * q * p + v * p) % N

    # Compute y = (x % 2p) - p
    y = (x % (_sage_const_2  * p)) - p

    # If y is zero, it means no error is detected in sp
    if y == _sage_const_0 :
        return False
    else:
        return True



# Generate key pairs
N, e, d, p, q = generate_keys()

# Sign a message using CRT
msg = "Hello, world!"
s = sign_message(msg, N, d, p, q)
print("Signature:", s)

# Simulate error in sp
sp_error = power_mod(randint(_sage_const_1 , p - _sage_const_1 ), d % (p - _sage_const_1 ), p)

# Recover factorization from s and sp_error using Bellcore attack
factorization = recover_factorization(N, sp_error, s % q, p, q)
print("Recovered Factorization:", factorization)

# Detect error in sp using Bellcore attack
error_detected = detect_error(N, sp_error, s % q, p, q)
if error_detected:
    print("Error in sp detected!")
else:
    print("No error detected in sp.")

